from pathlib import Path
import pandas as pd
import re
import shutil
import pathlib
from snakemake.utils import validate
include: 'rules/cellprofiler.smk'
include: 'rules/ilastik.smk'
# The main entry point of your workflow.
# After configuring, running snakemake -n in a clone of this repository should successfully execute a dry-run of the workflow.

#configfile: 'config/config_prepare.yml'

# Allow users to fix the underlying OS via singularity.
#singularity: "docker://votti/miniconda3mamba:v0.4.2"
conda: 'envs/env_base.yaml'
validate(config, "schemas/config_evaluate.schema.yml")

cp_plugins = 'resources/ImcPluginsCP/plugins'

cellprofiler_container = 'docker://cellprofiler/cellprofiler:4.0.7'
ilastik_container = 'docker://ilastik/ilastik-from-binary:1.3.3post3'
ilastik_python = '/ilastik-release/bin/python'
ilastik_bin = '/ilastik-release/run_ilastik.sh'
imctools_container = config['varia']['imctools_container']


config_ilastik = {
    'container': ilastik_container,
    'threads': 8,
    'mem_mb': 10000
}

ilastik_container = config_ilastik['container']
ilastik_threads = config_ilastik['threads']
ilastik_mem_mb = config_ilastik['mem_mb']
# Input
# Regular expressions to extract data from crop filenames
# params
# Output
fol_path_results = Path(config['project_id'])

file_path_panel = fol_path_results / 'panel.csv'

fn_config_prepare_data = config['config_prepare']
project_id = config['project_id']
csv_metal = config['csv_metal']
csv_stack_ilastik = config['csv_stack_ilastik']
config_stacks = {'ilastik': {'col_bool': csv_stack_ilastik,
                                     'min_image_size': 50}}

fol_path_project = pathlib.Path(f"{project_id}")
suffix_full_probablities = '_FullProbabilities'
suffix_tiff = '.tiff'



subworkflow prepare_data:
    workdir: '../../prepare_data/'
    snakefile:
             "../../prepare_data/workflow/Snakefile"
    configfile:
              fn_config_prepare_data

fn_path_panel = prepare_data(str(fol_path_project / 'panel.csv'))
fol_path_ome = prepare_data(str(fol_path_project / 'ome'))
file_path_img_meta = prepare_data(str(fol_path_project / 'training_image_meta.csv'))
fol_path_ilastik_cropinput = fol_path_project / 'cropinput_ilastik'
fol_path_labels=prepare_data(str(fol_path_project / 'training_labels')),
file_path_feature_matrix=prepare_data(str(fol_path_project / 'feature_matrix.txt')),

# Output:
file_path_ilastik_all = fol_path_project / 'ilastik_trained_full.ilp'
fol_pat_stack = fol_path_results / 'stacks_{stack}'
fol_path_stack_ilastik = str(fol_pat_stack).format(**{'stack': 'ilastik'})
fol_path_ilastik_crops = fol_path_results / 'crops_ilastik'
file_pat_ilastik_crop = fol_path_ilastik_crops / '{cropname}.h5'
file_pat_ilastik_loo_classifier = fol_path_results / 'loo_class/{cropname}.ilp'
file_pat_ilastik_loo_probabilities = fol_path_results / 'loo_prob/{cropname}_ProbabilitiesLoo.tiff'

fol_path_probab_all = fol_path_project / 'probabilities_all'

fol_path_seg_comparison = fol_path_project / 'segmentation_comparison'

fol_pat_masks = fol_path_project / 'masks_{maskversion}'
fol_pat_mask_labels = fol_path_project / 'masks_{maskversion}_labels'

fol_path_all_masks = str(fol_pat_masks).format(maskversion='all')
fol_path_loo_masks = str(fol_pat_masks).format(maskversion='loo')
fol_path_all_masks_labels = str(fol_pat_mask_labels).format(maskversion='all')
fol_path_loo_masks_labels = str(fol_pat_mask_labels).format(maskversion='loo')

has_all = fol_path_project / 'all'

def training_crops(wildcards):
    checkpoints.cp_training_crops.get(**wildcards)
    fn_pat = str(file_pat_ilastik_crop)
    crops, = glob_wildcards(fn_pat)
    return crops

def loo_classifiers(wildcards):
    crop_names = training_crops(wildcards)
    return expand(file_pat_ilastik_loo_classifier, cropname=crop_names)

def loo_probabilities(wildcards):
    crop_names = training_crops(wildcards)
    return expand(file_pat_ilastik_loo_probabilities, cropname=crop_names)

rule all:
    input: fol_path_stack_ilastik, fol_path_ilastik_crops,
         file_path_ilastik_all, fol_path_probab_all, loo_classifiers,
         loo_probabilities, fol_path_loo_masks, fol_path_results, fol_path_seg_comparison
    output: touch(has_all)



checkpoint cp_training_crops:
    input:
        fol_path_ilastik_crops
    output:
        temporary(fol_path_project / 'has_training_crops')
    shell:
        'touch {output[0]}'

rule ome2analysis:
    input:
         fol_ome = fol_path_ome,
         panel = fn_path_panel
    output:
          directory(str(fol_pat_stack))
    container:
             imctools_container
    params:
          column_used = lambda wildcards: config_stacks[wildcards.stack][
              'col_bool'],
          column_metal = csv_metal,
          suffix = '_{stack}',
          min_imgsize = lambda wildcards: config_stacks[wildcards.stack][
              'min_image_size']
    threads: 8
    resources:
             mem_mb=8000,
             time="80"
    script:
          'scripts/imc2analysis.py'

rule crop_reproduction_input:
    input:
        fol_ilastik=fol_path_stack_ilastik,
        fn_cropmeta=file_path_img_meta
    output:
        fol_cropinput=directory(fol_path_ilastik_cropinput)
    run:
        fol_cropinput = Path(output.fol_cropinput)
        fol_ilastik = Path(input.fol_ilastik)
        dat_cropmeta = pd.read_csv(input.fn_cropmeta)
        fol_cropinput.mkdir()
        for _, row in dat_cropmeta.iterrows():
            fn_inp = fol_ilastik / f"{row['basename']}_ilastik.tiff"
            fn_out = fol_cropinput / f"{row['cropname']}.tiff"
            fn_out.symlink_to(fn_inp.resolve())

rule get_mask_labels:
    input:
        fol_masks = str(fol_pat_masks),
        fn_cropmeta = file_path_img_meta,
        fol_labels = fol_path_labels
    output:
        fol_mask_labels = directory(str(fol_pat_mask_labels))
    run:
        fol_mask_labels = Path(output.fol_mask_labels)
        fol_masks = Path(input.fol_masks)
        fol_labels = Path(input.fol_labels[0])
        dat_cropmeta = pd.read_csv(input.fn_cropmeta)
        fol_mask_labels.mkdir()
        fns_masks = [f.name for f in fol_masks.glob('*.tiff')]
        for _, row in dat_cropmeta.iterrows():
            basename = row['basename']
            cropname = row['cropname']
            prefix = '{basename}_x{x}_y{y}_w{w}_h{h}'.format(**dict(row))
            for f in fns_masks:
                if f.startswith(prefix):
                    fn_inp = fol_labels / f"{cropname}_label.tiff"
                    fn_out = fol_mask_labels / f.replace('.tiff', '_label.tiff')
                    fn_out.symlink_to(fn_inp.resolve())


rule get_trained_classifier:
    input:
        fol_labels=fol_path_labels,
         fol_imgs=fol_path_ilastik_crops,
         fn_feature_matrix=file_path_feature_matrix,
         fn_file_meta=file_path_img_meta
    params:
        glob_img=lambda wildcards: '"{basename}_x{x}_y{y}_w{w}_h{h}.h5"'
    resources:
             mem_mb=8000,
             time="80"
    output:
        file_path_ilastik_all
    container: ilastik_container
    shell:
        """
        LAZYFLOW_THREADS={threads} LAZYFLOW_TOTAL_RAM_MB={resources.mem_mb} \
        {ilastik_python} workflow/scripts/train_headless.py {output[0]}\
            {input.fol_imgs} \
            {input.fol_labels} \
            {input.fn_file_meta} \
            {input.fn_feature_matrix} \
            {params.glob_img}
            
        """

rule get_trained_loo_classifier:
    input: file_path_ilastik_all
    output: file_pat_ilastik_loo_classifier
    threads: 4
    resources:
        mem_mb=4000
    params:
        file_name_crop = '{cropname}'
    container: ilastik_container
    shell:
         """
         LAZYFLOW_THREADS={threads} LAZYFLOW_TOTAL_RAM_MB={resources.mem_mb} \
         {ilastik_python} workflow/scripts/loo_img_training.py \
            {input[0]} \
            "{params.file_name_crop}" \
            "{output[0]}"
         """

rule apply_ilastik_loo:
    input:
         fn = file_pat_ilastik_crop,
         project = file_pat_ilastik_loo_classifier
    output:
        file_pat_ilastik_loo_probabilities

    container: ilastik_container
    threads: 4
    resources:
        mem_mb = 8000
    params:
        bin_ilastik=ilastik_bin,
        output_format='tiff',
        output_filename= lambda wildcards: str(file_pat_ilastik_loo_probabilities).replace('cropname', 'nickname'),
        export_source='Probabilities',
        export_dtype='uint16',
        export_drange='"[0, 65535]"',
        pipeline_result_drange='"[0.0, 1.0]"'
    shell:
        'LAZYFLOW_THREADS={threads} LAZYFLOW_TOTAL_RAM_MB={resources.mem_mb} {params.bin_ilastik} '
        '--headless --project="{input.project}" '
        '--output_format={params.output_format} '
        '--output_filename_format={params.output_filename} '
        '--export_source={params.export_source} '
        '--export_dtype={params.export_dtype} '
        '--export_drange={params.export_drange} '
        '--pipeline_result_drange={params.pipeline_result_drange} '
        '--readonly 1 '
        '"{input.fn}"'


def get_seg_probabilities(name, input_list, output_folder):
    dic = {
        'message':  """\
                    This will segment the ilastik probabilities.                
                    """,
        'run_size': 3,
        'plugins': cp_plugins,
        'pipeline': 'resources/2_segment_probabilities.cppipe',
        'input_files': input_list,
        'output_patterns': {'.':
                                directory(output_folder)}
    }
    return {name: dic}

config_dict_cp = {
        'ilastik_crops':
{
        'message':  """\
                    Prepare ilastik crops
                    
                    This will prepare ilastik crops by reproducing
                    the pre-labeled                    
                    """,
        'run_size': 3,
        'plugins': cp_plugins,
        'pipeline': 'resources/1_prepare_ilastik.cppipe',
        'input_files': [
            fol_path_ilastik_cropinput,
            file_path_img_meta
        ],
        'output_patterns': {'.':
                            directory(fol_path_ilastik_crops)},
        'input_folder': prepare_data(str(fol_path_project))
    },
    **get_seg_probabilities('seg_probab_all',
                            input_list=[fol_path_probab_all],
                            output_folder=fol_path_all_masks),

    **get_seg_probabilities('seg_probab_loo',
                            input_list=[loo_probabilities],
                            output_folder=fol_path_loo_masks),

    'all':
        {'message': """\
                    Runs ilastik classifier run on full dataset
                    """,
         'project': str(file_path_ilastik_all),
         'run_size': 4,
         'output_format': 'tiff',
         'output_filename': f'{{nickname}}{suffix_full_probablities}{suffix_tiff}',
         'export_source': 'Probabilities',
         'export_dtype': 'uint16',
         'pipeline_result_drange': '"[0.0, 1.0]"',
         'export_drange': '"[0, 65535]"',
         'input_files':
         # Folder containing process hdf5
         # images for ilastik pixel classification
             fol_path_ilastik_crops,
         'output_pattern':
         # Folder containing probability maps for segmentation
             directory(fol_path_probab_all)
         },
}

config_dict_ilastik = {
    'evaluate_masks':
        {
            'message':  """\
                        Evaluate masks using manual lablels
                        """,
            'run_size': 3,
            'plugins': cp_plugins,
            'pipeline': 'resources/3_evaluate_masks.cppipe',
            'input_files': [
                fol_path_all_masks,
                fol_path_all_masks_labels,
                fol_path_loo_masks,
                fol_path_loo_masks_labels
            ],
            'output_patterns': {'.':
                                    directory(fol_path_seg_comparison)},
            'input_folder': prepare_data(str(fol_path_project))
        },
}

define_cellprofiler_rules(config_dict_cp, fol_path_results, container_cp=cellprofiler_container)
define_ilastik_rules(config_dict_ilastik, fol_path_results, threads=ilastik_threads,
                     mem_mb=ilastik_mem_mb, container_ilastik=ilastik_container, bin_ilastik=ilastik_bin)
